<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.36" />
  <meta name="author" content="Weikun Han">
  <meta name="description" content="M.S. student, focusing on Natural Language Processing and Machine Learning">

  
  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="/css/highlight.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  


  

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  

  

  
  <link rel="alternate" href="https://weikunhan.github.io/index.xml" type="application/rss+xml" title="Weikun Han">
  <link rel="feed" href="https://weikunhan.github.io/index.xml" type="application/rss+xml" title="Weikun Han">
  

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="https://weikunhan.github.io/post/2017-11-13/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="og:site_name" content="Weikun Han">
  <meta property="og:url" content="https://weikunhan.github.io/post/2017-11-13/">
  <meta property="og:title" content="The Summary of Learning to Search for Dependencies | Weikun Han">
  <meta property="og:description" content="">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2017-11-13T00:00:00-08:00">
  
  <meta property="article:modified_time" content="2017-11-13T00:00:00-08:00">
  

  

  <title>The Summary of Learning to Search for Dependencies | Weikun Han</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/">Weikun Han</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#publications_selected">
            
            <span>Publications</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#projects">
            
            <span>Projects</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Blog</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <div class="article-inner">
      <h1 itemprop="name">The Summary of Learning to Search for Dependencies</h1>

      

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2017-11-13 00:00:00 -0800 PST" itemprop="datePublished">
      Nov 13, 2017
    </time>
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    7 min read
  </span>
  

  
  

  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=The%20Summary%20of%20Learning%20to%20Search%20for%20Dependencies&amp;url=https%3a%2f%2fweikunhan.github.io%2fpost%2f2017-11-13%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fweikunhan.github.io%2fpost%2f2017-11-13%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fweikunhan.github.io%2fpost%2f2017-11-13%2f&amp;title=The%20Summary%20of%20Learning%20to%20Search%20for%20Dependencies"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fweikunhan.github.io%2fpost%2f2017-11-13%2f&amp;title=The%20Summary%20of%20Learning%20to%20Search%20for%20Dependencies"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=The%20Summary%20of%20Learning%20to%20Search%20for%20Dependencies&amp;body=https%3a%2f%2fweikunhan.github.io%2fpost%2f2017-11-13%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>


      <div class="article-style" itemprop="articleBody">
        

<h2>Table of Contents</h2>
<nav id="TableOfContents">
<ul>
<li><a href="#1-introduction">1. Introduction</a></li>
<li><a href="#2-learning-to-search">2. Learning to search</a></li>
<li><a href="#3-dependency-parsing-by-learning-to-search">3. Dependency Parsing by Learning to Search</a></li>
<li><a href="#4-experimental-results">4. Experimental Results</a></li>
<li><a href="#5-related-works">5. Related Works</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
</nav>


<h1 id="1-introduction">1. Introduction</h1>

<p>Transition-based dependency parsers are a type of popular tool for solving structured prediction problems or joint prediction problems. There are many constructions for transition-based dependency parsers such as transition systems, feature engineering, neural-network predictors and the importance of training against a “dynamic oracle.” In short, those methods rely on the heuristic learning strategies.</p>

<p>In contrast to previous approaches, in this paper, they focus on building dependency parsers which have a compiler can automatically translate a simple specification of dependency parsing and labeled data into machine learning updates. In this way, dependency parsers can use machine learning technology to get more accuracy in complex prediction problems.</p>

<p>The credit assignment is an issue in complex prediction problems. There are two common ways:</p>

<ul>
<li>The system may ignore the possibility that a previous prediction may have been wrong. Alternatively, ignore that different errors may have different costs (consequences). Alternatively, that train-time prediction may differ from the test-time prediction. These and other issues lead to statistical inconsistency: when features are not rich enough for perfect prediction the machine learning may converge suboptimally.</li>
<li>The system may use handcrafted credit assignment heuristics to cope with errors the underlying algorithm makes and the long-term outcomes of decisions.</li>
</ul>

<p>For some applications, for example, the dependency parsing, it can be much more complicated if applying two strategies.</p>

<p>In the paper, they show a learning to search compiler (or credit assignment compiler) can handle credit assignment when applied to dependency parsing. Moreover, the advantages are as follows:</p>

<ul>
<li>The system automatically employs a cost sensitive learning algorithm instead of a multiclass learning algorithm, ensuring the model learns to avoid compounding errors.</li>
<li>The system automatically “rolls in” with the learned policy and “rolls out” the dynamic oracle insuring competition with the oracle.</li>
<li>Advanced machine learning techniques or optimization strategies are enabled with command-line flags with no additional implementation overhead, such as neural networks or “fancy” online learning.</li>
<li>The implementation is future-friendly: future compilers may yield a better parser.</li>
<li>Train/test asynchrony bugs are removed. Essentially, you only write the test-time “decoder” and the oracle.</li>
<li>The implementation is simple: This one is about 300 lines of C++ code.</li>
</ul>

<p>To sum up, the author explains the system in four parts: introducing solve structured prediction tasks using learning to search, implementing learning to search to solve dependency parsing, experimental result, and related work.</p>

<h1 id="2-learning-to-search">2. Learning to search</h1>

<p>Learning to search is a family of approaches for solving structured prediction problems or joint prediction problems. Learning to search includes many algorithms such as the incremental structured perceptron, SEARN, DAGGER, AGGREVATE, and others. On the whole, these algorithms have the similar framework, but their difference are in the rollin/rollout policy and the base learner.</p>

<p>In this paper, they build an efficient framework using imperative learning to search, in figure 1. In the framework, it includes:</p>

<ul>
<li>a “decoder” for the target structured prediction task (e.g., dependency parsing),</li>
<li>an annotation in the decoder that computes losses on the training data,</li>
<li>a reference policy on the training data that returns at any prediction point a “suggestion” as to an excellent action to take in that state.</li>
</ul>

<p>To fully understand this proposed framework, we need back to the concept of the learning to search.

<figure >
    
        <img src="/img/post/2017-11-13_1.jpg" />
    
    
    <figcaption>
        <h4>The workflow of the proposed framework.</h4>
        
    </figcaption>
    
</figure>
</p>

<p>Learning to search approaches solve structured prediction problems by (1) decomposing the production of the structured output regarding a specific search space (states, actions); and (2) learning hypotheses that control policy that takes actions in this search space. Figure 2 provides an example to illustrate the learning to search approach. In this example, it executes the program three times and able to explore three different trajectories and compute their losses.  The rollin policy determines the initial trajectory, the state R is the position of one-step deviations and the rollout policy is to complete the trajectory after a deviation. In brief, the learning to search first follows the learned policy to finds different predictions from the base learner, yields low Hamming loss and gets the reference policy.

<figure >
    
        <img src="/img/post/2017-11-13_2.png" />
    
    
    <figcaption>
        <h4>A schematic of the search space implicitly defined by an imperative program.</h4>
        
    </figcaption>
    
</figure>
</p>

<p>By varying the rollin/rollout policy and base learner, it can come up different algorithms. In this paper, their rollin=mixture of the learned and the reference (dynamic oracle) policies and rollout=reference (dynamic oracle) policy, and their base learner has varied options. In contrast, DAGGER uses the rollin=learned policy and the rollout=reference policy, and SEARN uses the rollin=rollout=stochastic mixture of learned and reference policies. Next, we will explore the implementation of the learning to search to solve dependency parsing.</p>

<h1 id="3-dependency-parsing-by-learning-to-search">3. Dependency Parsing by Learning to Search</h1>

<p>A transition-based dependency parser takes a sequence of actions and parses a sentence from left to right by maintaining a stack S, a buffer B, and a set of dependency arcs. An example in figure 3 whos a processing. To classify transition-based dependency parsers, we can learn from three aspects which are the transition system, the base learner, and the reference policy. There are three primary transition systems: arc-standard, arc-eager, arc-hybrid. For the base learner, it can be diverse such as perceptron, natural network, and SGD. As for the reference policy, there are greedy, beam search, and dynamic oracles.

<figure >
    
        <img src="/img/post/2017-11-13_3.png" />
    
    
    <figcaption>
        <h4>An illustrative example of an arc-hybrid transition parser.</h4>
        
    </figcaption>
    
</figure>
</p>

<p>In this paper, they use arc-hybrid for the transition system, the natural network for the base learner (also try more powerful base learners), and dynamic oracles for the reference policy. The arc-hybrid includes three actions: SHIFT, REDUCE, and REDUCE-RIGHT. For others transition system, those have more actions than arc-hybrid. The fundamental principle of dynamic oracles is that for some transition systems there is more than one path that could lead to the gold tree. In contrast, for greedy parsing, we are only considering one of them, which is the one determined by the deterministic oracle. In short, all frameworks are similar as discussed in section 2, but the implementation can be much more comfortable.</p>

<p>In section 2, to implement a parser using the learning to search framework, we need to provide a decoder, a loss function, and reference policy. Therefore, the author provides six functions:</p>

<ul>
<li>GETVALIDACTION returns a set of valid actions that can be taken based on the current configuration.</li>
<li>GETFEAT extracts features based on the current configuration.</li>
<li>GETGOLDACTION  implements the dynamic Oracle</li>
<li>PREDICT   is a library call implemented in the learning to search system.</li>
<li>TRANS function implements the hybrid-arc transition system.</li>
<li>LOSS function is used to measure the distance between the predicted output and the gold annotation.</li>
</ul>

<p>To notice that, there are two LOSS functions, one for unlabeled dependency parser and other for labeled dependency parser.</p>

<p>Compare with other implementation, the learning to search compiler have two advantages for implementation: First, in the learning to search framework, there is no need to implement a learning algorithm. Second, learning to search provides a unified framework, which allows the library to serve common functions for ease of implementation.</p>

<h1 id="4-experimental-results">4. Experimental Results</h1>

<p>Experiments on standard English Penn Treebank and nine other languages from CoNLL-X show that the compiled parser is competitive with recently published results (see figure 4 and figure 5).

<figure >
    
        <img src="/img/post/2017-11-13_4.png" />
    
    
    <figcaption>
        <h4>Parser settings.</h4>
        
    </figcaption>
    
</figure>


<figure >
    
        <img src="/img/post/2017-11-13_5.png" />
    
    
    <figcaption>
        <h4>Unlabeled attachment scores (UAS) and labeled attachment scores (LAS).</h4>
        
    </figcaption>
    
</figure>
</p>

<h1 id="5-related-works">5. Related Works</h1>

<p>Some works use the learning to search approach to solve various other structured prediction problems, but these works are a unique setting under author’s unified learning framework. In conclusion, the learning to search compiler is the first work that develops a general programming interface for dependency parsing, or more broadly, for structured prediction.</p>

<h1 id="reference">Reference</h1>

<ol>
<li>Kai-Wei Chang, He He, Hal Daume III, and John Langford. 2015a. Learning to Search for Dependencies. arXiv:1503.05615.</li>
<li>Ballesteros, Miguel. &ldquo;Transition-based Dependency Parsing.&rdquo; 2015. <a href="http://demo.clab.cs.cmu.edu/fa2015-11711/images/b/b1/TbparsingSmallCorrection.pdf" target="_blank">PowerPoint presentation</a></li>
</ol>

      </div>

      


<div class="article-tags">
  
  <a class="btn btn-primary btn-outline" href="/tags/learning-to-search">learning to search</a>
  
  <a class="btn btn-primary btn-outline" href="/tags/dependency-parsing">dependency parsing</a>
  
  <a class="btn btn-primary btn-outline" href="/tags/paper-summary">paper summary</a>
  
</div>



    </div>
  </div>

</article>






<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Weikun Han &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    

    
    <script async defer src="//maps.googleapis.com/maps/api/js?key=AIzaSyCr1co0A6IZNyPIYZTvO_gSxAFScR13D6k"></script>
    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gmaps.js/0.4.25/gmaps.min.js" integrity="sha256-7vjlAeb8OaTrCXZkCNun9djzuB2owUsaO72kXaFDBJs=" crossorigin="anonymous"></script>
    
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

